// Generated by CoffeeScript 2.3.1
(function() {
  var LuacheckError, argparse, fs, os, path, subprocess;

  argparse = require("./argparse");

  LuacheckError = require("./Error");

  subprocess = require("child_process");

  fs = require("fs");

  os = require("os");

  path = require("path");

  module.exports = function(filename, options, next) {
    var args, cwd, err, exec;
    // arg shuffling
    if (typeof options === "function") {
      next = options;
      options = null;
    }
    if (options == null) {
      options = {
        async: true
      };
    }
    // arg sanity check
    if (typeof filename !== "string") {
      err = new Error("Please pass in a filename");
      if (options.async) {
        return next(err);
      }
      throw err;
    }
    // figure out what to run
    if (options.exec != null) {
      exec = options.exec;
    } else {
      exec = "luacheck";
      if (os.platform() === "win32") {
        exec += ".bat";
      }
    }
    // figure out where to run it from
    if (options.cwd) {
      cwd = options.cwd;
    } else {
      cwd = path.dirname(filename);
    }
    // construct args
    args = [path.resolve(".", filename), "--quiet", "--ranges", "--codes", "--no-color", "--formatter", "plain"].concat(argparse(options));
    if (options.async) {
      if (typeof next !== "function") {
        next = function() {
          return void 0;
        };
      }
      return module.exports._luacheckAsync(filename, exec, args, cwd, next);
    } else {
      return module.exports._luacheckSync(filename, exec, args, cwd);
    }
  };

  module.exports._getErrors = function(data) {
    var errors, i, len, line, match, ref, regexp;
    regexp = /^(.+)\:(\d+)\:(\d+)\:\s*\(([EW]\d+)\)\s*(.+)$/;
    errors = [];
    ref = data.split(/\r?\n/);
    for (i = 0, len = ref.length; i < len; i++) {
      line = ref[i];
      match = regexp.exec(line);
      if (match) {
        errors.push(new LuacheckError(match));
      }
    }
    return errors;
  };

  module.exports._luacheckAsync = function(filename, exec, args, cwd, next) {
    return fs.stat(filename, function(err, stats) {
      var child, stdout;
      if (err) {
        return next(err);
      }
      if (!stats.isFile()) {
        return next(new Error(`'${filename}' is not a file`));
      }
      child = subprocess.spawn(exec, args, {
        cwd: cwd,
        encoding: "utf-8"
      });
      stdout = "";
      child.stdout.on("data", function(data) {
        return stdout += data;
      });
      child.on("error", next);
      return child.on("close", function(code) {
        return next(null, module.exports._getErrors(stdout));
      });
    });
  };

  module.exports._luacheckSync = function(filename, exec, args, cwd) {
    var child, stats;
    stats = fs.statSync(filename);
    if (!stats.isFile()) {
      throw new Error(`'${filename}' is not a file`);
    }
    child = subprocess.spawnSync(exec, args, {
      cwd: cwd,
      encoding: "utf-8"
    });
    if (child.error) {
      throw child.error;
    }
    return module.exports._getErrors(child.stdout);
  };

}).call(this);
